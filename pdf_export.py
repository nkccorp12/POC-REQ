"""
PDF Export functionality for the Describe-to-Radar POC
Creates comprehensive PDF reports with search results, radar charts, and molecule structures
"""

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import pandas as pd
from datetime import datetime
import io
from PIL import Image
from typing import List, Optional
import base64

from visualization import create_radar_chart_matplotlib, render_molecule_structure, get_top_panel_words
from config import PANEL_WORDS


def create_pdf_report(prompt: str, rata_vector: np.ndarray, results_df: pd.DataFrame, 
                     filename: Optional[str] = None) -> bytes:
    """
    Create a comprehensive PDF report of search results
    
    Args:
        prompt: Original search prompt
        rata_vector: 55-dimensional RATA vector
        results_df: Search results dataframe
        filename: Optional filename, if None generates timestamp-based name
        
    Returns:
        PDF bytes for download
    """
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"odor_search_report_{timestamp}.pdf"
    
    # Create PDF in memory
    pdf_buffer = io.BytesIO()
    
    with PdfPages(pdf_buffer) as pdf:
        # Page 1: Title and Overview
        _create_title_page(pdf, prompt, rata_vector, results_df)
        
        # Page 2: Radar Chart and Top Descriptors
        _create_radar_page(pdf, prompt, rata_vector)
        
        # Page 3+: Molecule Results (3 per page)
        _create_molecule_pages(pdf, results_df)
        
        # Add metadata
        d = pdf.infodict()
        d['Title'] = f'Odor Search Report: {prompt}'
        d['Author'] = 'Describe-to-Radar POC'
        d['Subject'] = 'Molecular Odor Search Results'
        d['Keywords'] = 'Odor, Molecules, AI, Principal Odor Map'
        d['Creator'] = 'Streamlit + matplotlib'
        d['CreationDate'] = datetime.now()
    
    pdf_buffer.seek(0)
    return pdf_buffer.getvalue()


def _create_title_page(pdf: PdfPages, prompt: str, rata_vector: np.ndarray, results_df: pd.DataFrame):
    """Create title page with search overview"""
    fig, ax = plt.subplots(figsize=(8.5, 11))
    ax.axis('off')
    
    # Title
    ax.text(0.5, 0.95, 'ðŸ§ª Describe-to-Radar', 
            fontsize=24, fontweight='bold', ha='center', transform=ax.transAxes)
    ax.text(0.5, 0.90, 'AI-Powered Odor Molecule Search Report', 
            fontsize=16, ha='center', transform=ax.transAxes)
    
    # Search details
    ax.text(0.5, 0.80, 'Search Query', 
            fontsize=18, fontweight='bold', ha='center', transform=ax.transAxes)
    
    # Wrap long prompts
    wrapped_prompt = _wrap_text(prompt, 60)
    ax.text(0.5, 0.75, f'"{wrapped_prompt}"', 
            fontsize=14, ha='center', transform=ax.transAxes, 
            style='italic', bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray"))
    
    # Results summary
    ax.text(0.5, 0.65, 'Results Summary', 
            fontsize=18, fontweight='bold', ha='center', transform=ax.transAxes)
    
    summary_text = f"""
â€¢ Found {len(results_df)} similar molecules
â€¢ Search conducted on {datetime.now().strftime("%B %d, %Y at %H:%M")}
â€¢ Based on 55-dimensional odor descriptors
â€¢ Uses Principal Odor Map (POM) embeddings
    """
    ax.text(0.5, 0.55, summary_text, 
            fontsize=12, ha='center', va='top', transform=ax.transAxes)
    
    # Top descriptors preview
    top_words = get_top_panel_words(rata_vector, 8)
    ax.text(0.5, 0.35, 'Top Odor Descriptors', 
            fontsize=16, fontweight='bold', ha='center', transform=ax.transAxes)
    
    descriptor_text = " â€¢ ".join([f"{word} ({score:.3f})" for word, score in top_words if score > 0.01])
    wrapped_descriptors = _wrap_text(descriptor_text, 80)
    ax.text(0.5, 0.30, wrapped_descriptors, 
            fontsize=11, ha='center', va='top', transform=ax.transAxes)
    
    # Footer
    ax.text(0.5, 0.05, 'Generated by Describe-to-Radar POC â€¢ Based on Lee et al., Science 2023', 
            fontsize=10, ha='center', transform=ax.transAxes, color='gray')
    
    pdf.savefig(fig, bbox_inches='tight')
    plt.close(fig)


def _create_radar_page(pdf: PdfPages, prompt: str, rata_vector: np.ndarray):
    """Create page with radar chart and detailed descriptors"""
    fig = plt.figure(figsize=(8.5, 11))
    
    # Title with more space from top
    fig.suptitle(f'Odor Profile Analysis', fontsize=18, fontweight='bold', y=0.92)
    
    # Radar chart (top half)
    ax1 = plt.subplot(2, 1, 1, polar=True)
    
    # Create radar chart data
    N = len(PANEL_WORDS)
    angles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()
    values = rata_vector.tolist()
    values += values[:1]  # Complete the circle
    angles += angles[:1]
    
    # Plot radar
    ax1.plot(angles, values, 'o-', linewidth=2, color='blue', markersize=4)
    ax1.fill(angles, values, alpha=0.25, color='blue')
    ax1.set_xticks(angles[:-1])
    ax1.set_xticklabels(PANEL_WORDS, fontsize=8)
    ax1.set_ylim(0, max(rata_vector) * 1.1 if max(rata_vector) > 0 else 1)
    ax1.grid(True)
    ax1.set_title(f'Odor Vector Profile\n"{_wrap_text(prompt, 40)}"', 
                  fontsize=14, fontweight='bold', pad=20)
    
    # Top descriptors table (bottom half) - with more spacing
    ax2 = plt.subplot(2, 1, 2)
    ax2.axis('off')
    
    # Get top descriptors
    top_words = get_top_panel_words(rata_vector, 15)
    
    ax2.text(0.5, 0.95, 'Top 15 Odor Descriptors', 
             fontsize=16, fontweight='bold', ha='center', transform=ax2.transAxes)
    
    # Create table data
    table_data = []
    for i, (word, score) in enumerate(top_words, 1):
        if score > 0.001:  # Only show meaningful scores
            table_data.append([f"{i}.", word.title(), f"{score:.4f}"])
    
    if table_data:
        # Split into two columns for better layout
        mid = len(table_data) // 2
        left_data = table_data[:mid]
        right_data = table_data[mid:]
        
        # Left column
        y_start = 0.85
        for i, (rank, word, score) in enumerate(left_data):
            y_pos = y_start - i * 0.06
            ax2.text(0.1, y_pos, f"{rank} {word}", fontsize=11, transform=ax2.transAxes)
            ax2.text(0.4, y_pos, score, fontsize=11, transform=ax2.transAxes, fontfamily='monospace')
        
        # Right column
        for i, (rank, word, score) in enumerate(right_data):
            y_pos = y_start - i * 0.06
            ax2.text(0.6, y_pos, f"{rank} {word}", fontsize=11, transform=ax2.transAxes)
            ax2.text(0.9, y_pos, score, fontsize=11, transform=ax2.transAxes, fontfamily='monospace')
    
    plt.tight_layout()
    pdf.savefig(fig, bbox_inches='tight')
    plt.close(fig)


def _create_molecule_pages(pdf: PdfPages, results_df: pd.DataFrame):
    """Create pages with molecule structures and details (3 per page)"""
    molecules_per_page = 3
    total_pages = (len(results_df) + molecules_per_page - 1) // molecules_per_page
    
    for page_num in range(total_pages):
        start_idx = page_num * molecules_per_page
        end_idx = min(start_idx + molecules_per_page, len(results_df))
        page_molecules = results_df.iloc[start_idx:end_idx]
        
        fig, axes = plt.subplots(molecules_per_page, 2, figsize=(8.5, 11), 
                                gridspec_kw={'width_ratios': [1, 2]})
        
        # Handle single molecule case
        if molecules_per_page == 1:
            axes = axes.reshape(1, -1)
        
        fig.suptitle(f'Similar Molecules (Page {page_num + 1}/{total_pages})', 
                     fontsize=16, fontweight='bold')
        
        for i, (_, mol_row) in enumerate(page_molecules.iterrows()):
            row_idx = i
            
            # Get SMILES
            smiles = mol_row.get('smiles', mol_row.get('nonStereoSMILES', ''))
            
            # Molecule structure (left column)
            ax_img = axes[row_idx, 0] if molecules_per_page > 1 else axes[0, 0]
            ax_img.axis('off')
            
            mol_img = render_molecule_structure(smiles, size=(300, 300))
            if mol_img:
                ax_img.imshow(mol_img)
                ax_img.set_title(f"Rank {start_idx + i + 1}", fontweight='bold')
            else:
                ax_img.text(0.5, 0.5, f"Could not render\n{smiles}", 
                           ha='center', va='center', transform=ax_img.transAxes)
            
            # Molecule details (right column)
            ax_text = axes[row_idx, 1] if molecules_per_page > 1 else axes[0, 1]
            ax_text.axis('off')
            
            # Create details text
            details = []
            details.append(f"Similarity Score: {mol_row['similarity_score']:.4f}")
            details.append(f"SMILES: {smiles}")
            
            if 'name' in mol_row and pd.notna(mol_row['name']):
                details.append(f"Name: {mol_row['name']}")
            
            # Add descriptor information if available
            if 'descriptors' in mol_row and pd.notna(mol_row['descriptors']):
                descriptors = str(mol_row['descriptors'])
                wrapped_desc = _wrap_text(f"Descriptors: {descriptors}", 40)
                details.append(wrapped_desc)
            
            details_text = "\n\n".join(details)
            ax_text.text(0.05, 0.95, details_text, 
                        transform=ax_text.transAxes, fontsize=10, 
                        va='top', ha='left')
        
        # Hide unused subplot areas
        for i in range(len(page_molecules), molecules_per_page):
            if molecules_per_page > 1:
                axes[i, 0].axis('off')
                axes[i, 1].axis('off')
        
        plt.tight_layout()
        pdf.savefig(fig, bbox_inches='tight')
        plt.close(fig)


def _wrap_text(text: str, width: int) -> str:
    """Simple text wrapping utility"""
    if len(text) <= width:
        return text
    
    words = text.split()
    lines = []
    current_line = []
    current_length = 0
    
    for word in words:
        if current_length + len(word) + 1 <= width:
            current_line.append(word)
            current_length += len(word) + 1
        else:
            if current_line:
                lines.append(' '.join(current_line))
            current_line = [word]
            current_length = len(word)
    
    if current_line:
        lines.append(' '.join(current_line))
    
    return '\n'.join(lines)


def get_pdf_download_link(pdf_bytes: bytes, filename: str) -> str:
    """Generate base64 download link for PDF"""
    b64 = base64.b64encode(pdf_bytes).decode()
    return f'data:application/pdf;base64,{b64}'


if __name__ == "__main__":
    # Test PDF generation
    import pandas as pd
    
    # Mock data for testing
    test_prompt = "fresh, citrusy, with grassy notes"
    test_rata = np.random.rand(55)
    test_results = pd.DataFrame({
        'nonStereoSMILES': ['CCO', 'CC(C)O', 'CCCO'],
        'similarity_score': [0.95, 0.87, 0.82],
        'descriptors': ['alcoholic;fresh', 'alcoholic;sweet', 'alcoholic;fatty']
    })
    
    pdf_bytes = create_pdf_report(test_prompt, test_rata, test_results)
    
    with open('test_report.pdf', 'wb') as f:
        f.write(pdf_bytes)
    
    print("Test PDF created: test_report.pdf")